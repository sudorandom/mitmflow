package main

import (
	"encoding/base64"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestParseGrpcWebFrames(t *testing.T) {
	tests := []struct {
		name    string
		input   string
		want    []string
		wantErr bool
	}{
		{
			name:  "empty response",
			input: "AAAAAAA=",
			want:  []string{""},
		},
		{
			name:  "response with data and trailer",
			input: "AAAAAAYiBAhkKAqAAAAAEGdycGMtc3RhdHVzOiAwDQo=",
			want: []string{
				"4: {\n  1: 100\n  5: 10\n}\n",
				"grpc-status: 0\r\n",
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			data, err := base64.StdEncoding.DecodeString(tt.input)
			if err != nil {
				t.Fatalf("failed to decode base64 string: %v", err)
			}
			got, err := parseGrpcWebFrames(data, nil, nil, nil)
			if tt.wantErr {
				require.Error(t, err)
				return
			}
			require.NoError(t, err, tt.wantErr)
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestParseGrpcFramesWithDescriptor(t *testing.T) {
	registry := NewRegistry()
	// Ensure the file exists before running this test, or generate it as part of the test setup if feasible.
	// For now, we assume testdata/eliza.binpb is present (generated by buf build).
	err := registry.LoadFromFiles([]string{"testdata/eliza.binpb"})
	require.NoError(t, err)

	// Lookup the Say method
	// Package: connectrpc.eliza.v1
	// Service: ElizaService
	// Method: Say
	inputDesc, outputDesc, err := registry.LookupMethod("/connectrpc.eliza.v1.ElizaService/Say")
	require.NoError(t, err)
	require.NotNil(t, inputDesc)
	require.NotNil(t, outputDesc)

	// Construct a SayRequest: sentence="Hello"
	// Field 1 (sentence), wire type 2 (length delimited) -> tag 0x0A
	// Length 5
	// "Hello"
	payload := []byte{
		0x0A, 0x05, 'H', 'e', 'l', 'l', 'o',
	}

	// Create gRPC frame
	// Compressed: 0
	// Length: 7
	frame := make([]byte, 5+len(payload))
	frame[0] = 0
	frame[4] = byte(len(payload)) // Simple length setting for small payload
	copy(frame[5:], payload)

	frames, err := parseGrpcFrames(frame, nil, inputDesc)
	require.NoError(t, err)
	require.Len(t, frames, 1) // Should have JSON and protoscope output

	// Check for JSON output
	assert.Contains(t, frames[0], `"sentence"`)
	assert.Contains(t, frames[0], `"Hello"`)
}

func TestProcessProtobufMessage_ConnectUnary(t *testing.T) {
	registry := NewRegistry()
	err := registry.LoadFromFiles([]string{"testdata/eliza.binpb"})
	require.NoError(t, err)

	inputDesc, _, err := registry.LookupMethod("/connectrpc.eliza.v1.ElizaService/Say")
	require.NoError(t, err)

	// Raw protobuf message: "Hello"
	payload := []byte{0x0A, 0x05, 'H', 'e', 'l', 'l', 'o'}

	frames := processProtobufMessage(payload, inputDesc)

	require.Len(t, frames, 1) // JSON

	assert.Contains(t, frames[0], `"sentence"`)
	assert.Contains(t, frames[0], `"Hello"`)
}

func TestParseConnectStreamingFrames(t *testing.T) {

	// Frame 1: Data "Hello" (Flag 0)
	payload1 := []byte{0x0A, 0x05, 'H', 'e', 'l', 'l', 'o'}
	frame1 := make([]byte, 5+len(payload1))
	frame1[0] = 0x00
	frame1[4] = byte(len(payload1))
	copy(frame1[5:], payload1)

	// Frame 2: Trailer (Flag 0x02) - JSON: {"error":null}
	trailerJSON := []byte(`{"error":null}`)
	frame2 := make([]byte, 5+len(trailerJSON))
	frame2[0] = 0x02
	frame2[4] = byte(len(trailerJSON))
	copy(frame2[5:], trailerJSON)

	fullPayload := append(frame1, frame2...)

	frames, err := parseConnectStreamingFrames(fullPayload, nil)
	require.NoError(t, err)
	// Expect 2 frames: Protoscope (no desc) for data, and JSON string for trailer
	require.Len(t, frames, 2)
	assert.Contains(t, frames[0], `Hello`)       // Protoscope output
	assert.Equal(t, `{
  "error": null
}`, frames[1]) // Trailer
}

func TestParseGrpcFramesWithDescriptor_Streaming(t *testing.T) {
	registry := NewRegistry()
	err := registry.LoadFromFiles([]string{"testdata/eliza.binpb"})
	require.NoError(t, err)

	inputDesc, _, err := registry.LookupMethod("/connectrpc.eliza.v1.ElizaService/Say")
	require.NoError(t, err)

	// Message 1: "Hello"
	payload1 := []byte{0x0A, 0x05, 'H', 'e', 'l', 'l', 'o'}
	frame1 := make([]byte, 5+len(payload1))
	frame1[0] = 0
	frame1[4] = byte(len(payload1))
	copy(frame1[5:], payload1)

	// Message 2: "World"
	payload2 := []byte{0x0A, 0x05, 'W', 'o', 'r', 'l', 'd'}
	frame2 := make([]byte, 5+len(payload2))
	frame2[0] = 0
	frame2[4] = byte(len(payload2))
	copy(frame2[5:], payload2)

	// Concatenate frames
	fullPayload := append(frame1, frame2...)

	frames, err := parseGrpcFrames(fullPayload, nil, inputDesc)
	require.NoError(t, err)
	// Expect 4 frames: JSON1, Protoscope1, JSON2, Protoscope2
	require.Len(t, frames, 2)

	assert.Contains(t, frames[0], `"sentence"`)
	assert.Contains(t, frames[0], `"Hello"`)
	assert.Contains(t, frames[1], `"sentence"`)
	assert.Contains(t, frames[1], `"World"`)
}
